
    // // int x;
    // // float b;

    // std::vector<int> v;

    // for(int i = 0; i < 10; i++) {
    //     // std::cout << "Digite um numero: ";
    //     v.push_back(i);
    // }

    // // int var : container
    // // a variavel recebe o próximo valor do container a cada iteração
    // // equivale a percorrer o vetor do inicio ao fim
    // for(int x : v) {
    //     std::cout << x;
    //     if (x < static_cast<int>(v.size()) - 1) {
    //         std::cout << ", ";
    //     }
    // }
    
    // std::string linha;

    // std::cin >> linha;  //aqui lê até o espaço
    // std::cin.ignore();  // consome um caracter do buffer, nesse caso o espaço
    // std::cout << linha << "\n";

    // //aqui vai ler o resto do buffer "aranha\n" e vai printas
    // std::getline(std::cin, linha); //aqui lê até o \n
    // std::cout << linha;

    
    // std::cout << "Type an int, then type a float.\n";
    // std::cin >> a >> b;
    // std::cout << "You typed: " << a << ", " << b << "\n";

    // v.push_back(a);
    // v.push_back(b); //aqui é pra dar erro ou truncar

    // std::cout << "v[0]: " << v[0] << "\nv[1]: " << v[1] << "\n";

    Graph g(5);
    g.addEdge(0, 1, 2);
    g.addEdge(0, 3, 3);
    g.addEdge(1, 2, 3);
    g.addEdge(3, 1, 1);

    std::vector<Graph::Edge> a_edges;
    a_edges = g.neighbours(0);

    for ( Graph::Edge& e : a_edges ) {
        std::cout << e.to << " " << e.weight << "\n";
    }

    std::cout << "Tamanho: " << g.size() << "\n";

        // std::cout << "Hello C++!\n";
    std::ifstream file("data/teste.txt"); //ifstream = input file stream

    // testa se conseguiu abrir o arquivo
    if(!file.is_open()) {
        std::cout << "Erro ao abrir o arquivo!\n";
        exit(1);
    }

    std::string x;

    // Operadores >> e <<
    // >> dados entrando (input). Você está enviando o dado pra algo. Leitura do arquivo
    // << dados saindo (output). O dado também tá indo pra algo, como output. Escrita no arquivo
    // É um pouco confuso pra mim ainda, não vou mentir. Mas deve ser questão de prática.

    // Isso tenta ler um valor do arquivo e atribuir à X.
    // O retorno é true se conseguiu, false se não. (no caso do EOF ele retorna false e quebra o loop)
    while(std::getline(file, x)) {
        std::cout << x << "\n";
    }

    return 0;


    using json = nlohmann::json; //só pra escrever menos coisa. Faz json ser uma keywork que é nlohmann::json
    
    json j_file;
    std::ifstream file("data/nodes.json");

    if(!file.is_open()) {
        std::cout << "Erro ao abrir o arquivo!\n";
        exit(1);
    }   

    // Joga o fluxo de entrada de caracteres do arquivo pro tipo json da biblioteca.
    // Esse tipo se vira automaticamente pra saber oq tem no json, se um array ou objeto, ou array de objetos etc.
    // A partir daqui o j_file é representado de acordo com a estrutura dele, e eu acesso como array de objetos
        // no caso do nodes.json
    file >> j_file; 

    // Cria uma hashtable
    std::unordered_map<long long, int> idToIndex;
    
    // indica pra hashtable q eu vou botar +- esse tanto de elementos
    // isso evita várias realocações durante um loop, por exemplo. É tipo aquele tamanho inicial quando eu implementei
    idToIndex.reserve(j_file.size()); 


    int i = 0;
    for(auto& node : j_file) {
        // A ordem dos números do nodo pra mim não interessa. Me interessa que o id vire um número pequeno.
        long long id = node["id"];
        idToIndex[id] = i;  //isso aqui faz o id sempre mapear pro index i, na mesma ordem que eles tão escrito no json

        std::cout << "ID: " << id << "\tINDEX: " << idToIndex[id] << "\n";

        // faz só pros 10 primeiros pra testar
        i++;
        if(i >= 10) {
            break;
        }
    }



    dijkstra testa
    Graph g(7);
    
    g.addEdge(0, 2, 3);
    g.addEdge(2, 0, 3);

    g.addEdge(0, 5, 2);
    g.addEdge(5, 0, 2);

    g.addEdge(2, 5, 2);
    g.addEdge(5, 2, 2);

    g.addEdge(2, 4, 1);
    g.addEdge(4, 2, 1);
    
    g.addEdge(5, 4, 3);
    g.addEdge(4, 5, 3);

    g.addEdge(2, 3, 4);
    g.addEdge(3, 2, 4);

    g.addEdge(3, 1, 1);
    g.addEdge(1, 3, 1);

    g.addEdge(4, 1, 2);
    g.addEdge(1, 4, 2);

    g.addEdge(5, 1, 6);
    g.addEdge(1, 5, 6);

    g.addEdge(5, 6, 5);
    g.addEdge(6, 5, 5);

    g.addEdge(1, 6, 2);
    g.addEdge(6, 1, 2);

    Dijkstra dj(g, 0);

    dj.execute();
    
    // Ta errado
    std::cout << "Distance from A0 to B1: "<< dj.getDistance(1) << "\n";

    dj.getPath(1);